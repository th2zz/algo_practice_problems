# 递归与递推
一个实际问题各种可能情况构成的集合为 状态空间，程序的运行实则为对状态空间的遍历。算法数据结构帮助我们改善状态空间遍历的时空效率。
递归和递推是程序遍历状态空间的两种基本方式。

已知的问题边界=》原问题 正向推导 = 递推
然而很多时候，推导的路线难以确定，从原问题为起点，尝试把状态空间缩小到已知的问题边界的路线，
再通过该路线反向回溯的遍历方式就是递归。

使用递归或递推要求原问题和问题边界之间的变换步骤具有相似性，这样才能通过一段程序重复作用于问题之中。
程序在每个步骤上面对的都是原问题的一个子问题，可能只是在规模或某些限制条件上有所区别，并且能够使用求解原问题的程序进行求解。

对于递归算法 有了上面的前提，我们就可以让程序在每个变换步骤中 执行3个操作：
1. 缩小问题状态空间的规模: 尝试寻找 原问题 =》 问题边界 的变换路线，并向正在探索的路线上迈出一步。
2. 尝试求解规模缩小以后的问题， 结果可能是成功，可能是失败
3. 如果成功，则将子问题答案拓展到当前问题。 如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直到确认当前问题无法求解。

上述思路的关键在于
1. 求解规模更小的问题 是求解原问题的一个子问题 可以使用相同的程序 “自身调用自身”
2. 如果求解子问题失败，程序需要回到当前问题去寻找其他的变换路线：因此需要撤回在把当前问题缩小为子问题时对当前问题状态的修改 “回溯时还原现场”

# 递归dfs解题思路
DFS通常用于解决排列和组合问题 以及暴力搜索动态规划(memo dp)等各种np问题

理解题目含义

- 递归的定义 
  - 递归参数 需要什么? 什么含义？ 
  - 这样的递归定义如何帮助我们求解问题本身？
  - 不同规模的问题相比 相同的问题结构是什么
- 递归的出口 先思考递归的base case都有哪些
- 递归的拆解和递进
  - 如何拆解出同样问题结构的子问题  子问题唯一的不同是参数的数据规模不同 
  - 子问题应当朝base case进行递进
  - 这个过程像在先反向proof by induction  然后再递推
    - 先证明几个base case, 假设k is true(induction hypothesis) prove k + 1 is true; 
    - 先假设我们的递归定义能够magically solve the problem, 那么他也能magically solve规模更小的问题
      - 终点和出口 是base case base case是比较trival的 直接得出结论

    
  
组合问题通常需要index作为递归参数 因为常用的累积式 组合搜索树是一个渐进的过程
需要通过index来作为新的 子问题起点

排列问题一般不需要index作为递归参数 但需要visited判断是否选过

重复的元素需要选择有代表性的一个 是比较简单的去重方法